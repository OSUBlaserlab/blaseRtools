# Helper functions
#' @importFrom GenomicRanges makeGRangesFromDataFrame
#' @importFrom BiocGenerics as.data.frame
#' @importFrom dplyr mutate filter
buff_granges <- function(x, gen) {
    std_chroms <-c(as.character(1:25), paste0("chr", 1:25), "X", "Y", "chrX", "chrY")
    x_df <- as.data.frame(x) %>%
      as_tibble() %>%
      mutate(seqnames = as.character(seqnames)) %>%
      filter(seqnames %in% std_chroms) %>%
      mutate(seqnames = ifelse(str_detect(seqnames, "chr"), seqnames, paste0("chr", seqnames)))

    x <- makeGRangesFromDataFrame(x_df, keep.extra.columns = T)
    genome(x) <- gen
    return(x)
}

#' @importFrom IRanges subsetByOverlaps
trim_and_drop_levels <- function(x, trim_to) {
  x <- subsetByOverlaps(x, trim_to, type = "within")
  seqlevels(x, pruning.mode = "tidy") <- seqlevels(trim_to)
  return(x)
}

#' An S4 class to Hold Genome Track Data
#'
#' @description An instance of this class is created by calling "bb_makeTrace".  All slots in this object are coerced to GRanges objects.  It is easiest to have everything start in UCSC-formated GRanges format but this is not necessary.  Validation checks will make sure data, features, links, and gene models all are bound by the same plot range on the same chromosome of the same genome.  Currently hg38 and danRer11 are the supported genomes.  Use this class to plot coverage tracks from ATAC or similar experiments.  Link plotting is available for cicero-style links.
#'
#' @slot trace_data A Granges object or a dataframe coercible to a GRanges object.  bb_makeTrace should be able to handle NCBI or UCSC formatting styles.  Data will be rewritten as the latter.  Trace data should have a metadata column for "score" or "coverage" intended to be plotted as a y-variable.  Trace data must be normalized and combined into a single GRanges or dataframe before loading.  A group variable should be included to annotate color and and facets in the final plotting.  Whole sample bigwig files can be converted to GRanges objects using import.bw from rtracklayer.  All track data is trimmed during import but pre-trimming to the approximate range desired will significantly speed up processing.
#' @slot features A GRanges object containing features to plot in a track-style format.  This object should include a "type" column to enable plotting each type in its own track.  All features of a given type are plotted on the same line.
#' @slot links A GRanges object with Cicero-style links.  Must be GRanges but can be in either NCBI or UCSC format.
#' @slot gene_model The gene model for plotting.  Will be automatically generated by bb_makeTrace.
#' @slot plot_range The master GRange for the whole object.  Validity checks and/or constructors ensure all other ranges are contained within.
#' @import methods
#' @export Trace
#' @exportClass Trace
Trace <- setClass(
  "Trace",
  slots = list(
    trace_data = "GRanges",
    features = "GRanges",
    links = "GRanges",
    gene_model = "GRanges",
    plot_range = "GRanges"

  )
)

#' Show a Trace Object
#'
#' @export
setMethod("show",
          "Trace",
          function(object) {
            cat(paste0("A Trace object from genome " ,
                       genome(object@trace_data),
                       ", sequence ",
                       names(genome(object@trace_data))))
            cat(paste0(".\n\nThe plot range is set to ",
                start(object@plot_range), "-",
                end(object@plot_range)), ".")
          })

# Validity Check
#' @export
setValidity("Trace", function(object) {
  if (genome(object@trace_data) %notin% c("danRer11", "hg38"))
    return("The trace data genome must be either danRer11 or hg38")
  if (genome(object@trace_data) != genome(object@features))
    return("The trace data and features genomes must match.")
  if (genome(object@trace_data) != genome(object@links))
    return("The trace data and links genomes must match.")
  if (genome(object@trace_data) != genome(object@gene_model))
    return("The trace data and gene model genomes must match.")
  if (genome(object@trace_data) != genome(object@plot_range))
    return("The trace data and plot range genomes must match.")
  if (levels(seqnames(object@trace_data)) != levels(seqnames(object@features)))
    return("The trace data and features seqnames must match.")
  if (levels(seqnames(object@trace_data)) != levels(seqnames(object@links)))
    return("The trace data and links seqnames must match.")
  if (levels(seqnames(object@trace_data)) != levels(seqnames(object@gene_model)))
    return("The trace data and gene model seqnames must match.")
  if (levels(seqnames(object@trace_data)) != levels(seqnames(object@plot_range)))
    return("The trace data and plot range seqnames must match.")
  if (length(object@plot_range) != 1)
    return("The plot range must have length 1.")

})

#' Construct a Trace object from a Dataframe
#'
#' @description Use this function to create a trace object.  See details of the trace class for a complete description. Generally data can be in either NCBI or UCSC style.
#'
#' @param trace_data A GRanges object or dataframe coercible to a GRanges object.  Should have metadata columns for "score" or "coverage" and "group".
#' @param startcol The dataframe column containing the start position.  Required only if trace_data is a dataframe.  Ignored if trace_data is a GRanges object.
#' @param endcol The dataframe column containing the end position.  Required only if trace_data is a dataframe.  Ignored if trace_data is a GRanges object.
#' @param genome The genome for the analysis.  Required.
#' @param seqname The sequence name, generally chromosome number.  Not required if trace_data is a GRanges object.
#' @param plot_range The bounding range for all slots in the object.  Everything will be trimmed to this range during generation of the object.  Can be shrunk after creation but not expanded.  There are three options for setting this:  1.  An explicit GRanges object can be provided.  2.  A valid gene name can be provided.  3.  Default:  the plot_range is set to match the initial range of the trace_data.  This last case will err if trace_data spans multiple chromosomes as is he case with unfiltered whole-sample bigwigs.
#' @param extend_left Bases to extend plot_range left, or upstream relative to the top strand.
#' @param extend_right Bases to extend plot_range right, or downstream relative to the top strand.
#' @param features A GRanges object with features to plot.  Should include a "type" metadata column for all feature types likely to be plotted.  Optional
#' @param links A GRanges object with cicero-style gene links.  Optional
#'
#'
#' @import GenomicRanges tidyverse
#' @export
bb_makeTrace <- function(trace_data,
                             startcol = NULL,
                             endcol = NULL,
                             genome = c("hg38", "danRer11"),
                             seqname = NULL,
                             plot_range = "trace",
                             extend_left = 0,
                             extend_right = 0,
                             features = NULL,
                             links = NULL) {

  stopifnot("You must choose either hg38 or danRer11 for the genome" = genome %in% c("hg38", "danRer11") & length(genome) == 1)

  # make the trace_data GRanges object
  if ("data.frame" %in% class(trace_data)) {
    stopifnot("You must identify supply startcol when using a data frame for this function." = !is.null(startcol))
    stopifnot("You must identify supply endcol when using a data frame for this function." = !is.null(endcol))
    stopifnot("You must identify supply a seqname when using a data frame for this function." = !is.null(seqname))
    trace_data <- trace_data %>% mutate(seqname = seqname)
    gr <- makeGRangesFromDataFrame(
      trace_data,
      keep.extra.columns = TRUE,
      start.field = startcol,
      end.field = endcol,
      seqnames.field = "seqname"
    )

  } else if ("GRanges" %in% class(trace_data)) {
    gr <- trace_data
  } else {
    return("Trace data must either be a data frame or a GRanges object.")
  }
  gr <- buff_granges(gr, gen = genome)

  # make the initial plot_range
  available_genes <- c(mcols(hg38_full_model_gr)$gene_name,
                       mcols(dr11_full_model_gr)$gene_name)

  if (genome == "hg38") {
    full_gene_model = hg38_full_model_gr
  } else if (genome == "danRer11") {
    full_gene_model = dr11_full_model_gr
  } else {
    return("You must specify and available genome.")
  }

  if (class(plot_range) == "GRanges") {
    plot_range_init <- plot_range
  } else if (plot_range %in% available_genes) {
    selected_range <- full_gene_model[mcols(full_gene_model)$gene_name %in% plot_range]
    plot_range_init <- range(selected_range)
  } else if (plot_range == "trace") {
    plot_range_init <- range(gr)
  } else {
    return("You must specify an appropriate range to plot.")
  }
  start(plot_range_init) <- start(plot_range_init) - extend_left
  end(plot_range_init) <- end(plot_range_init) + extend_right
  plot_range_init <- buff_granges(plot_range_init, gen = genome)
  # seqlevels(plot_range_init, pruning.mode = "tidy") <- seqlevels(gr)

  # trim the data to reduce size
  gr <- trim_and_drop_levels(x = gr, trim_to = plot_range_init)
  seqname <- unique(as.vector(seqnames(plot_range_init)))

  # get the species-specific gene-model
  selected_gene_model <- trim_and_drop_levels(x = full_gene_model, trim_to = plot_range_init)

  # add in the features
  if (!is.null(features)) {
    features_to_add <- features
  } else {
    # add in a zero-length feature to hold the place
    features_to_add <-GRanges(seqnames = seqname, ranges = IRanges(
                              start = start(plot_range_init) +1,
                              end = start(plot_range_init))

    )
  }

  features_to_add <- buff_granges(features_to_add, gen = genome)

  # trim the features
  features_to_add <- trim_and_drop_levels(x = features_to_add, trim_to = plot_range_init)

  # add in the links
  if (!is.null(links)) {
    links_to_add <- links
  } else {
    # add in a zero-length feature to hold the place
    links_to_add <-GRanges(seqnames = seqname,
                           ranges = IRanges(
                              start = start(plot_range_init) +1,
                              end = start(plot_range_init))

    )
  }

  links_to_add <- buff_granges(links_to_add, gen = genome)

  # trim the features
  links_to_add <- trim_and_drop_levels(x = links_to_add, trim_to = plot_range_init)

  theTrace <- Trace(trace_data = gr,
                    gene_model = selected_gene_model,
                    features = features_to_add,
                    links = links_to_add,
                    plot_range = plot_range_init

  )
  return(theTrace)
}

#' Get the Trace Data Slot from a Trace Object
#'
#' @export
setGeneric("Trace.data", function(trace)
  standardGeneric("Trace.data"))
#' @export
setMethod("Trace.data", "Trace", function(trace) trace@trace_data)

#' Get the Features Slot from a Trace Object
#'
#' @export
setGeneric("Trace.features", function(trace)
  standardGeneric("Trace.features"))
#' @export
setMethod("Trace.features", "Trace", function(trace) trace@features)

#' Get the Links Slot from a Trace Object
#'
#' @export
setGeneric("Trace.links", function(trace)
  standardGeneric("Trace.links"))
#' @export
setMethod("Trace.links", "Trace", function(trace) trace@links)

#' Get the gene_model Slot from a Trace Object
#'
#' @export
setGeneric("Trace.gene_model", function(trace)
  standardGeneric("Trace.gene_model"))
#' @export
setMethod("Trace.gene_model", "Trace", function(trace) trace@gene_model)


#' Get the plot_range Slot from a Trace Object
#'
#' @export
setGeneric("Trace.plot_range", function(trace) standardGeneric("Trace.plot_range"))
#' @export
setMethod("Trace.plot_range", "Trace", function(trace) trace@plot_range)

#' Set the Plot Range Slot of a GRanges Object
#'
#' @param trace An ape object
#' @param gr A GRanges object.  This object will become the new plot range.
#' @export
setGeneric("Trace.setRange", function(trace, gr)
  standardGeneric("Trace.setRange"))
#' @export
setMethod("Trace.setRange", "Trace", function(trace, gr) {
  trace@plot_range <- gr
  trace@trace_data <- trim_and_drop_levels(x = trace@trace_data, trim_to = gr)
  trace@features <- trim_and_drop_levels(x = trace@features, trim_to = gr)
  trace@gene_model <- trim_and_drop_levels(x = trace@gene_model, trim_to = gr)
  trace@links <- trim_and_drop_levels(x = trace@links, trim_to = gr)
  validObject(trace)
  trace
})

#' Set the Features Slot of a GRanges Object
#'
#' @param trace An ape object
#' @param gr A GRanges object.  This object will become the new plot features.
#' @export
setGeneric("Trace.setFeatures", function(trace, gr)
  standardGeneric("Trace.setFeatures"))
#' @export
setMethod("Trace.setFeatures", "Trace", function(trace, gr) {
  gr <- buff_granges(gr, gen = genome(trace@plot_range))
  new_features <- trim_and_drop_levels(x = gr, trim_to = trace@plot_range)
  trace@features <- new_features
  validObject(trace)
  trace
})

#' Set the Links Slot of a GRanges Object
#'
#' @param trace An ape object
#' @param gr A GRanges object.  This object will become the new plot links.
#' @export
setGeneric("Trace.setLinks", function(trace, gr)
  standardGeneric("Trace.setLinks"))
#' @export
setMethod("Trace.setLinks", "Trace", function(trace, gr) {
  gr <- buff_granges(gr, gen = genome(trace@plot_range))
  new_links <- trim_and_drop_levels(x = gr, trim_to = trace@plot_range)
  trace@links <- new_links
  validObject(trace)
  trace
})




# helper functions for plotting
set_range <- function(grange) {
  start <- min(start(grange))
  end <- max(end(grange))
  return(c(start, end))
}

#' @import ggplot2
theme_no_x <- function() {
  theme(axis.text.x = element_blank(),
        axis.ticks.x  = element_blank(),
        axis.title.x = element_blank(),
        axis.line.x = element_blank())
}

#' @import ggplot2
theme_no_y <- function() {
  theme(axis.text.y = element_blank(),
        axis.ticks.y  = element_blank(),
        axis.title.y = element_blank(),
        axis.line.y = element_blank())
}

#' @import ggplot2
theme_min_y <- function() {
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank())

}

#' Plot The Trace Data From A Trace Object
#'
#' @description A function to generate a line plot from tracklike genomic data.
#'
#' @param trace A Trace object
#' @param yvar The variable that will become the Y axis.  Defaults to "score".
#' @param facet_var The variable describing data facets.  Each will be placed as a separate horizontal track with the value printed to the left. Optional but recommended.
#' @param colvar The variable to color traces by.  Optional but recommended.
#' @param pal A color palette.  Can also be added after the fact.
#' @import tidyverse
#' @importFrom BiocGenerics as.data.frame
#' @export
bb_plot_trace_data <- function(trace,
                          yvar = "score",
                          facet_var = NULL,
                          colvar = NULL,
                          pal = NULL) {
  data_gr <- Trace.data(trace)
  data_tbl <-
    as.data.frame(data_gr) %>%
    as_tibble() %>%
    dplyr::mutate(mid = width / 2 + start)

  p <-ggplot(data = data_tbl,
             mapping = aes(x = mid,
                           y = !!sym(yvar)))
  if (!is.null(colvar)) {
    p <- p + geom_line(mapping = aes_string(color = colvar))
  } else {
    p <- p + geom_line()
  }
  if (!is.null(pal)) {
    stopifnot("You must specify a variable for the color palette." = !is.null(colvar))
    p <- p + scale_color_manual(values = pal,
                                breaks = names(pal))
  }

  if (!is.null(facet_var)) {
    p <- p + facet_wrap(facets = vars(!!sym(facet_var)), ncol = 1, strip.position = "left") +
      theme(strip.background = element_blank(),
            strip.text.y.left = element_text(angle = 0))
  }
  p <- p +
    xlim(set_range(Trace.plot_range(trace))) +
    theme_no_x() +
    theme(legend.position = "none")

  return(p)
}

#' Plot The Feature Data From A Trace Object
#'
#' @description A function to generate a feature plot from tracklike genomic data.
#'
#' @param trace A Trace object.  Should have a metadata column in the features slot named "type".
#' @param type_to_plot Value of the type variable to plot.  This will be come the Y-axis label.
#' @import tidyverse
#' @importFrom BiocGenerics as.data.frame
#' @export
bb_plot_trace_feature <- function(trace,
                                  type_to_plot) {
  gr <- Trace.features(trace)

  gr_tbl <-
    as.data.frame(gr) %>%
    as_tibble() %>%
    dplyr::mutate(mid = width/2 + start) %>%
    dplyr::filter(type == type_to_plot)

  p <- ggplot(data = gr_tbl,
              mapping = aes(x = mid,
                            y = type,
                            width = width)) +
    geom_tile(color = "black", fill = "grey60")

  p <- p +
    xlim(set_range(Trace.plot_range(trace))) +
    theme_no_x() +
    theme_min_y() +
    labs(y = type_to_plot)

  return(p)
}


#' Plot The Link Data From A Trace Object
#'
#' @description A function to generate a link plot from tracklike genomic data.  Links will automatically be trimmed to lie entirely within the plot range.  An additional, optionsl score cutoff can be provided.
#'
#' @param trace A Trace object containing a valid links slot.
#' @param cutoff Score cutoff for link plotting.  Defaults to 0.
#' @import tidyverse
#' @importFrom BiocGenerics as.data.frame
#' @import ggforce
#' @export
bb_plot_trace_links <- function(trace, cutoff = 0) {
  gr <- Trace.links(trace)

  gr_tbl <-
    as.data.frame(gr) %>%
    as_tibble() %>%
    dplyr::mutate(mid = width/2 + start) %>%
    dplyr::filter(score > cutoff) %>%
    distinct() %>%
    mutate(group = rank(-score))

  bezier_data <-
    tibble(x = c(gr_tbl$start,
                 gr_tbl$mid,
                 gr_tbl$end),
           y = c(rep(0, length(gr_tbl$start)),
                 rep(-1, length(gr_tbl$mid)),
                 rep(0, length(gr_tbl$end))),
           group = rep(gr_tbl$group, 3),
           score = rep(gr_tbl$score, 3)
    )

  p <- ggplot(data = bezier_data,
              mapping = aes(x = x,
                            y = y,
                            group = group,
                            color = score)) +
    ggforce::geom_bezier()
  p <- p +
    xlim(set_range(Trace.plot_range(trace))) +
    theme_no_x() +
    theme_min_y() +
    labs(y = "Links") +
    scale_color_gradient2(low = "red", mid = "grey", high = "blue")
  return(p)
}

#' @importFrom BiocGenerics as.data.frame
#' @import tidyverse
select_the_transcripts <- function(gr) {
    data <-
      as.data.frame(gr) %>%
      as_tibble() %>%
      group_by(gene_name, APPRIS, length, parent_transcript) %>%
      summarise() %>%
      ungroup() %>%
      group_by(gene_name) %>%
      arrange(APPRIS, desc(length)) %>%
      slice_head() %>%
      select(gene_name, parent_transcript) %>%
      deframe()
    return(data)

}


#' Plot The Gene Model From A Trace Object
#'
#' @description A function to generate a plot of the underlying gene model.  The genes to be plotted are automatically selected according to the genome build and the plot range. The function automatically picks the longest principle transcript to show.  Optionally, alternative transcripts can be shown by specifying the select_transcript argument.  This must be an ensembl transcript identifier lying within the plot range.
#'
#' @param trace A Trace object.
#' @param select_transcript Optional selected transcript(s) to plot.
#' @import tidyverse
#' @importFrom BiocGenerics as.data.frame
#' @export
bb_plot_trace_model <- function(trace,
                                select_transcript = NULL) {
  data_gr <- Trace.gene_model(trace)
  data_tbl <-
    mcols(data_gr) %>%
    as_tibble() %>%
    dplyr::mutate(start = start(data_gr)) %>%
    dplyr::mutate(end = end(data_gr)) %>%
    dplyr::mutate(mid = width(data_gr) / 2 + start) %>%
    dplyr::mutate(width = width(data_gr)) %>%
    dplyr::mutate(strand = as.vector(strand(data_gr))) %>%
    dplyr::mutate(ht = recode(
      type,
      "five_prime_UTR" = 0.5,
      "three_prime_UTR" = 0.5,
      "CDS" = 1
    ))

  transcripts <- select_the_transcripts(data_gr)
  if (!is.null(select_transcript)) {
    transcript_lookup <-
      bind_rows(as_tibble(mcols(hg38_full_model_gr)), as_tibble(mcols(dr11_full_model_gr)))
    selected <- transcript_lookup %>%
      filter(parent_transcript %in% select_transcript) %>%
      select(gene_name, parent_transcript) %>%
      deframe()
    # replace the original with selected transcripts
    transcripts[names(selected)] <- selected

  }

  data_to_plot <- data_tbl %>%
    filter(parent_transcript %in% transcripts)

  names_to_plot <- data_to_plot %>%
    group_by(gene_name, parent_transcript, strand) %>%
    summarise(gene_start = min(start), gene_end = max(end)) %>%
    mutate(mid_gene = (gene_start + gene_end) / 2)

  segments_to_plot <- map_dfr(
    .x = names_to_plot$gene_name,
    .f = function(x, data = names_to_plot) {
      filtered <- data %>%
        filter(gene_name == x)
      xpos <-
        seq.int(from = filtered$gene_start,
                to = filtered$gene_end,
                by = 1000)
      res <-
        tibble(
          gene_name = filtered$gene_name,
          parent_transcript = filtered$parent_transcript,
          xpos = xpos[-length(xpos)],
          xend = xpos + 1000,
          strand = filtered$strand
        )
      return(res)
    }
  )


  p <- ggplot() +
    geom_segment(
      data = filter(segments_to_plot, strand == "+"),
      mapping = aes(
        x = xpos,
        xend = xend,
        y = parent_transcript,
        yend = parent_transcript
      ),
      arrow = arrow(
        ends = "last",
        type = "open",
        angle = 45,
        length = unit(x = 0.05, units = "inches")
      )
    ) +
    geom_segment(
      data = filter(segments_to_plot, strand == "-"),
      mapping = aes(
        x = xpos,
        xend = xend,
        y = parent_transcript,
        yend = parent_transcript
      ),
      arrow = arrow(
        ends = "first",
        type = "open",
        angle = 45,
        length = unit(x = 0.05, units = "inches")
      )
    ) +
    geom_tile(
      data = data_to_plot,
      mapping = aes(
        x = mid,
        y = parent_transcript,
        width = width,
        height = ht
      ),
      color = "black",
      fill = "cornsilk"
    ) +
    geom_text(
      data = names_to_plot,
      mapping = aes(
        x = mid_gene,
        y = paste0(parent_transcript, "_gene"),
        label = gene_name
      ),
      size = 3
    )


  p <- p +
    xlim(set_range(Trace.plot_range(trace))) +
    theme_no_x() +
    theme_min_y() +
    labs(y = "Genes")

  return(p)
}


#' Plot The X Axis From A Trace Object
#'
#' @description Generates the X axis for stacking other track plots on top of.
#'
#' @param trace A Trace object.
#' @param xtitle An optional title for the X axis
#' @import tidyverse
#' @importFrom GenomicRanges
#' @export
bb_plot_trace_axis <- function(trace,
                               xtitle = NULL) {
  gr <- range(Trace.plot_range(trace))
  gr_tbl <-
    tibble(start = start(gr), end = end(gr)) %>%
    pivot_longer(everything())
  p <- ggplot(data = gr_tbl, mapping = aes(x = value))
  p <- p +
    xlim(set_range(Trace.plot_range(trace))) +
    theme_no_y() +
    labs(x = xtitle)
  return(p)
}
